define constant, begin

	#values for below items
	1, damage:normal
	2, damage:pure

	12,	ticks:default

	0,	targClass:foeNotDead
	1,	targclass:allyNotDead
	2,	targclass:self
	3,	targclass:allNotDead
	4,	targclass:deadAlly

	0,	targSetting:focus
	1,	targSetting:spread

	0,	preferTarg:random
	1,	preferTarg:strongest
	2,	preferTarg:weakest

	12, weakStrongStat:targetstat

	1,	status:poison
	2,	status:paralyze
	3,	status:confused
	4,	status:burnt
	5,	status:frozen
	6,	status:mute
	7,	status:stun
	8,	status:regen
	9,	status:invincible
	10, status:shell
	11, status:reflect
end
#=======================================================================
#=======================================================================

script, turns, begin
	variable (
		which, who, target, mod1, mod2, targstat, extdam
		sli, type, healing, damage, i, var, formation
	)
	sli := lookupslice(array:turn)
	sortChildren (sli)

	while (firstChild (lookupslice(array:turn))) do (
		sli := firstChild (lookupslice(array:turn))
		
		who		:= getElement(sli, 0)
		which	:= getElement(sli, 1)
		target	:= getElement(sli, 2)

		#when the skill needs to be decided
		if (which==-1) then (
			which := getenemyattacks (who)
		)

		returnSkill(which)
		sli := lookupslice (array:readskill)

		#when the target needs to be decided
		if (target==-1) then (
			switch (getElement (sli, skill:preferTarg)) do (
				case (preferTarg:random) do (
					while (true) do (
						target := random (0, herocount--1)
						if (readstat(target, stat:HP)>0) then (break)
					)
				)
			)
		)

		mod1 := readStat (who, getElement (sli,skill:baseAtkStat))
		mod2 := readStat (who, getElement (sli,skill:baseDefStat))

		damage	:= returndamage (
			mod1
			mod2
			getElement (sli,skill:extraDamage)
			getElement (sli,skill:damageMath)
			getElement (sli,skill:curebit)
		)

		if (getElement (sli,skill:rowcheck) == true && readStat(target, stat:row)==1) then (
			damage := damage -- damage/3
		)
		if (readStat(target, stat:defending)==true) then (
			damage := damage -- damage/2
		)

		var := (readstat(target, stat:aim) -- readstat(target, stat:evade))
		var += random(-1 * readstat(target, stat:aim)/8,  readstat(target, stat:aim)/8)
		#show value (var + 100)

		if (var + 100 >= 100) then (
			writeStat (target, getElement (sli,skill:targStat), readStat(target, getElement (sli,skill:targStat)) -- damage)
			if (readStat(target, getElement (sli,skill:targStat))<0) then(writeStat (target, getElement (sli,skill:targStat), 0))

			animation(which, target, damage, who)
		) else (
			animation(-1, target, damage, who)
		)
		for (i, 0, herocount--1) do (
			setmeter (i, stat:hp)
			setmeter (i, stat:pp)
		)

		if (readstat(target, stat:HP)==0) then (KOTarget(target))
		battlecheck
		freeSlice (firstChild (lookupslice(array:turn)))
	)
	initTurnArray()
	specwait (10)

	subscript, koTarget, targ, begin
		if (targ>3) then (
			targ -=4
			sli := first child (slice child (lookupslice(sli:enemygrid), targ))
			dissolveSprite (sli, dissolve:flicker, 22)
			specwait (20)
			set slice visible (sli, false)
		) else (
			updateportrait(targ)
		)
	end

	subscript, getenemyattacks, enemy, begin
		variable (normalatk1, normalatk2, normalatk3, normalatk4)
		formation := getElement(get array(array:battleinfo), battle:formation)
		enemy := formationSlotEnemy (formation, enemy--4)
		show value (enemy)
		switch (enemy) do (
			case (enemy:Rat King) do (
				normalatk1 := skill:normal
				normalatk2 := skill:normal
				normalatk3 := skill:normal
				normalatk4 := skill:normal
			)
			case (enemy:Doll Dancer) do (
				normalatk1 := skill:test
				normalatk2 := skill:test
				normalatk3 := skill:test
				normalatk4 := skill:test
			)
			case (enemy:Mushroom Man) do (
				normalatk1 := skill:normal
				normalatk2 := skill:normal
				normalatk3 := skill:normal
				normalatk4 := skill:normal
			)
			case (enemy:Tentas) do (
				normalatk1 := skill:normal
				normalatk2 := skill:normal
				normalatk3 := skill:normal
				normalatk4 := skill:normal
			)
			else (
				normalatk1 := skill:normal
				normalatk2 := skill:normal
				normalatk3 := skill:normal
				normalatk4 := skill:normal
			)
		)
		switch (random (1, 4)) do (
			case (1) do (return (normalatk1))
			case (2) do (return (normalatk2))
			case (3) do (return (normalatk3))
			case (4) do (return (normalatk4))
		)
	end

	subscript, readSkill, which, begin
		sli := getArray(array:readskill)

		getElement (sli, skill:frameTicks)
		getElement (sli, skill:sound)
		getElement (sli, skill:targClass)
		getElement (sli, skill:targSetting)
		getElement (sli, skill:preferTarg)
		getElement (sli, skill:weakStrongStat) 
		getElement (sli,skill:hits)
		getElement (sli,skill:damageMath)
		getElement (sli,skill:baseAtkStat)
		getElement (sli,skill:baseDefStat)
		getElement (sli,skill:targStat)
		getElement (sli,skill:extraDamage)
		getElement (sli,skill:PPcost)
		getElement (sli,skill:HPcost)
		getElement (sli,skill:MoneyCost)
		getElement (sli,skill:autoChooseTarg)
		getElement (sli,skill:stealitem)
		getElement (sli,skill:stealPercent)
		getElement (sli,skill:status)
		getElement (sli,skill:statusPercent)
		getElement (sli,skill:elementType)
		getElement (sli,skill:curebit)
		getElement (sli,skill:rowcheck)
	end
end

#=======================================================================
#=======================================================================

script, animation, which, target, damage, who, begin
	variable (sli, sli2, sli3, i, j, picture, ticks, loop, var, var2, var3)
	#setup to animate
	if (target < 4) then (
		sli := battlePortrait(target)
	) else (
		sli := first child (slice child(lookupslice(sli:enemygrid), target--4))
	)
	if (who > 3) then (
		sli3 := first child (slice child(lookupslice(sli:enemygrid), who--4))
	)

	if (which == -1) then (
		if (who > 3) then (
			var3 := sliceY(sli3)
			setSliceY (sli3, sliceY(sli3)+10)
			specwait(10)
		)
		sli2 := loadSmallEnemySprite(6)
		set parent (sli2, sli)
		for (i, 0, 14) do (
			set slice y (sli2, slicey(sli2)--1)
			specwait (2)
		)
		dissolve sprite (sli2, dissolve:puff, 20)
		for (i, 0, 9) do (
			set slice y (sli2, slicey(sli2)--1)
			specwait (2)
		)
		freeSlice (sli2)

		if (who > 3) then (
			setSliceY (sli3, var3)
		)
		exitScript ()
	)

	sli2 := lookupslice (array:readskill)	
	picture := getElement (sli2,skill:picture)
	ticks	:= getElement (sli2,skill:frameTicks)
	loop 	:= getElement (sli2,skill:loop)
	if (who > 3) then (
		var3 := sliceY(sli3)
		setSliceY (sli3, sliceY(sli3)+10)
		specwait(10)
	)

	if (picture<>0) then (
		sli2	:= loadAttackSprite (picture)
		set parent (sli2, sli)
		center slice (sli2)

		for (j, 0, loop--1) do (
			for (i, 0, 2) do (
				setSpriteFrame (sli2, i)
				specwait(ticks)
			)
		)
		free slice (sli2)
	)
	var := sliceX(sli)
	var2 := 1
	for (j, 0, loop--1) do (
		for (i,5,0,-1) do (
			setSliceX(sli,i*var2)
			var2 := var2 * -1
			specwait(5)
		)
	)
	setSliceX(sli, var)
	if (who > 3) then (
		setSliceY (sli3, var3)
	)
	#end animation
	endanimation(which, sli, damage, target)
end

script, endanimation, which, sli, damage, target, begin
	variable (i)

	variable(sli2, ones, tens, hundreds)

	hundreds := modulus(damage/100,10)
	tens := modulus(damage/10,10)
	ones := modulus(damage/1,10)

	if (target < 4) then (
		sli2 := battlePortrait(target)
	) else (
		sli2 := first child (slice child(lookupslice(sli:enemygrid), target--4))
	)

	sli:= createGrid(72, 24, 0, 3)
	set parent (sli, sli2)
	center slice (sli)

	if (hundreds <> 0) then(
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, hundreds+1)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, tens+1)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, ones+1)
	) else if (tens <> 0)then (
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, tens+1)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, ones+1)
	) else(
		sli2 := create container
		set parent (sli2, sli)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, ones+1)
	)
	for (i, 0, 14) do (
		set slice y (sli, slicey(sli)--1)
		specwait (2)
	)
	sli2 := firstChild(sli)
	while (sli2) do (
		if (slice is sprite (sli2)) then (dissolve sprite (sli2, dissolve:puff, 20))
		sli2 := nextSibling(sli2)
	)
	for (i, 0, 9) do (
		set slice y (sli, slicey(sli)--1)
		specwait (2)
	)
	free slice (sli)
end

script, returndamage, mod1, mod2, extdam, type, healing, begin
	variable (var)

	extdam := extdam+100

	switch (type) do (
		case (damage:normal) do (var := mod1 -- mod2/2)
		case (damage:pure) do (var := mod1)
	)
	#var := var + multdiv (var, extdam, 100)

	if (var < 0) then (var := 0)

	var := var * healing

	return (var)
end

