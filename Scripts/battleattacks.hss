script, addattack, which, who, target, begin
	variable (speed, sli)

	speed := readstat(who,stat:Speed)

	sli := initArray()
	setParent (sli, lookupslice(array:turn))
	setSortOrder (sli, 8000--speed + random(0,speed/20))

	append (sli, which)
	append (sli, who)
	append (sli, target)
end

script, removeattack, begin
	variable (sli)

	sli := lookupslice(array:turn)
	sli := last child (sli)
	free slice (sli)
end

#=======================================================================
#=======================================================================

script, turns, begin
	variable (
		which, who, target, mod1, mod2, targstat, extdam
		sli, type, healing, damage, i, var
	)
	
	sli := lookupslice(array:turn)
	sortChildren (sli)

	while (firstChild (lookupslice(array:turn))) do (
		sli := firstChild (lookupslice(array:turn))
		which		:= getElement(sli, 0)
		who			:= getElement(sli, 1)
		target		:= getElement(sli, 2)

		switch (which) do (
			case (attack:normal) do (
				mod1 := readStat (who, stat:Atk)
				mod2 := readStat (target, stat:Def)
				targstat := stat:curHP
				type := battle:normalDamage
				extdam := 0
				healing := 1
			)
		)

		damage	:= returndamage (mod1, mod2, extdam, type, healing)
		if (healing == 1 && readStat(target, stat:row)==1) then (
			damage := damage -- damage/3
		)
		writeStat (target, targstat, readStat(target, targstat) -- damage)
		if (readStat(target, targstat)<0) then(writeStat (target, targstat, 0))

		animation(which, target, damage)
		if (readstat(target, stat:curHP)==0) then (KOTarget(target))
		battlecheck

		freeSlice (firstChild (lookupslice(array:turn)))
	)
	initTurnArray()
	specwait (10)

	subscript, koTarget, targ, begin
		if (targ>3) then (
			targ -=4
			sli := first child (slice child (lookupslice(sli:enemygrid), targ))
			dissolveSprite (sli, dissolve:puff, 80)
			specwait (70)
			set slice visible (sli, false)
		)
	end
end

#=======================================================================
#=======================================================================

script, animation, which, target, damage, begin
	variable (sli, sli2, speed, max, i)
	#setup to animate
	if (target < 4) then (
		sli := slice child(lookupslice(sli:herogrid), target)
	) else (
		sli := sliceChild(lookupslice(sli:enemygrid), target--4)
	)
	setupanimation (which, target)
	switch (which) do (	
		case (attack:normal) do (max := 4)
	)

	for (i, 0, max) do (
		animating(which, sli, i)
	)

	#end animation
	endanimation(which, sli, damage, target)
end

script, setupanimation, which, sli, begin
	switch (which) do (
		case (attack:normal) do (
		)
	)
	return (sli)
end

script, animating, which, sli, i,  begin
	variable(sli2)
	switch (which) do (
		case (attack:normal) do (
			switch (i) do (
				case (1) do (
					sli2 := loadSliceCollection(2)
					set parent (sli2, sli)
					specwait (10)
					free slice (sli2)
				)
				case (2) do (
					sli2 := loadSliceCollection(3)
					set parent (sli2, sli)
					specwait (10)
					free slice (sli2)
				)
				case (3) do (
					sli2 := loadSliceCollection(4)
					set parent (sli2, sli)
					specwait (10)
					free slice (sli2)
				)
			)
			
		)
	)
end

script, endanimation, which, sli, damage, target, begin
	variable (i)
	switch (which) do (
		case (attack:normal) do (
		)
	)
	for (i, 0, 4) do (
		if (i, mod, 2) then (
			set slice x (sli, 6--i)
		) else (
			set slice x (sli, -6+i)
		)
		specwait (6)
	)

	variable(sli2, ones, tens, hundreds)

	hundreds := modulus(damage/100,10)
	tens := modulus(damage/10,10)
	ones := modulus(damage/1,10)

	if (target < 4) then (
		sli2 := slice child(lookupslice(sli:herogrid), target)
	) else (
		sli2 := slice child(lookupslice(sli:enemygrid), target--4)
	)

	sli:= createGrid(72, 24, 0, 3)
	set parent (sli, sli2)
	center slice (sli)

	if (hundreds <> 0) then(
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, hundreds+1)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, tens+1)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, ones+1)
	) else if (tens <> 0)then (
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, tens+1)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, ones+1)
	) else(
		sli2 := create container
		set parent (sli2, sli)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, ones+1)
	)
	for (i, 0, 14) do (
		set slice y (sli, slicey(sli)--1)
		specwait (2)
	)
	sli2 := firstChild(sli)
	while (sli2) do (
		if (slice is sprite (sli2)) then (dissolve sprite (sli2, dissolve:puff, 20))
		sli2 := nextSibling(sli2)
	)
	for (i, 0, 9) do (
		set slice y (sli, slicey(sli)--1)
		specwait (2)
	)
	free slice (sli)
end

script, returndamage, mod1, mod2, extdam, type, healing, begin
	variable (var)

	extdam := extdam+100

	switch (type) do (
		case (battle:normalDamage) do (var := mod1 -- mod2/2)
		case (battle:pureDamage) do (var := mod1)
	)
	#var := var + multdiv (var, extdam, 100)

	if (var < 0) then (var := 0)

	var := var * healing

	return (var)
end

