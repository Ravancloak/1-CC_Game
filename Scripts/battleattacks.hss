define constant, begin
	


	#values for below items
	1, damage:normal
	2, damage:pure
	
	30,	ticks:default

	1,	targClass:foeNotDead
	2,	targclass:allyNotDead
	3,	targclass:self
	4,	targclass:allNotDead
	5,	targclass:deadAlly

	1,	targSetting:focus
	2,	targSetting:spread

	1,	preferTarg:random
	2,	preferTarg:strongest
	3,	preferTarg:weakest

	#skill array names
	22,	skill:names
	1,	skill:picture
	2,	skill:frameTicks
	3,	skill:sound
	4,	skill:targClass
	5,	skill:targSetting
	6,	skill:preferTarg
	7,	skill:weakStrongStat
	8,	skill:hits
	9,	skill:damageMath
	10,	skill:baseAtkStat
	11,	skill:baseDefStat
	12,	skill:targStat
	13,	skill:extraDamage
	14,	skill:PPcost
	15,	skill:HPcost
	16,	skill:MoneyCost
	17, skill:autoChooseTarg
	18, skill:stealitem
	19,	skill:stealPercent
	20,	skill:status
	21,	skill:statusPercent
	22,	skill:elementType
end

script, returnSkill, which,  begin
	variable (sli, i, var)

	if (lookupSlice(array:readskill)<>-1) then (
		free slice (lookupSlice(array:readskill))
	)

	switch (which) do (
		case (1) do ()
		else (template)
	)


	subscript, template, begin 
			sli := initArray(array:readskill,0,-1)
			setParent (sli, lookupSlice(sli:battleCol))
		#damage
			var := damage:normal
			setElement (sli, skill:picture, var)
		#frameTicks
			var := ticks:default
			setElement (sli, skill:frameTicks, var)
		#sound
			var := 0
			setElement (sli, skill:sound, var) 
		#targClass
			var := targClass:foeNotDead
			setElement (sli, skill:targClass, var)
		#targSetting
			var := targSetting:focus
			setElement (sli, skill:targSetting, var)
		#preferTarg
			var := 0
			setElement (sli, skill:preferTarg, var)
		#weakStrongStat
			var := 0
			setElement (sli, skill:weakStrongStat, var) 
		#hits
			var := 0
			setElement (sli,skill:hits, var)
		#damageMath
			var := 0
			setElement (sli,skill:damageMath, var)
		#baseAtkStat
			var := 0
			setElement (sli,skill:baseAtkStat, var)
		#baseDefStat
			var := 0
			setElement (sli,skill:baseDefStat, var)
		#targStat
			var := 0
			setElement (sli,skill:targStat, var)
		#extraDamage
			var := 0
			setElement (sli,skill:extraDamage, var)
		#PPcost
			var := 0
			setElement (sli,skill:PPcost, var)
		#HPcost
			var := 0
			setElement (sli,skill:HPcost, var)
		#MoneyCost
			var := 0
			setElement (sli,skill:MoneyCost, var)
		#autoChooseTarg
			var := 0
			setElement (sli,skill:autoChooseTarg, var)
		#stealitem
			var := 0
			setElement (sli,skill:stealitem, var)
		#stealpercent
			var := 0
			setElement (sli,skill:stealPercent, var)
		#status
			var := 0
			setElement (sli,skill:status, var)
		#statusPercent
			var := 0
			setElement (sli,skill:statusPercent, var)
		#elementType
			var := 0
			setElement (sli,skill:elementType, var)
	end
end


#=======================================================================
#=======================================================================

script, turns, begin
	variable (
		which, who, target, mod1, mod2, targstat, extdam
		sli, type, healing, damage, i, var
	)
	sli := lookupslice(array:turn)
	sortChildren (sli)

	while (firstChild (lookupslice(array:turn))) do (
		sli := firstChild (lookupslice(array:turn))
		which		:= getElement(sli, 0)
		who			:= getElement(sli, 1)
		target		:= getElement(sli, 2)

		switch (which) do (
			case (attack:normal) do (
				mod1 := readStat (who, stat:Atk)
				mod2 := readStat (target, stat:Def)
				targstat := stat:HP
				type := damage:normal
				extdam := 0
				healing := 1
			)
		)

		damage	:= returndamage (mod1, mod2, extdam, type, healing)
		if (healing == 1 && readStat(target, stat:row)==1) then (
			damage := damage -- damage/3
		)
		writeStat (target, targstat, readStat(target, targstat) -- damage)
		if (readStat(target, targstat)<0) then(writeStat (target, targstat, 0))

		animation(which, target, damage)
		if (readstat(target, stat:HP)==0) then (KOTarget(target))
		battlecheck

		freeSlice (firstChild (lookupslice(array:turn)))
	)
	initTurnArray()
	specwait (10)

	subscript, koTarget, targ, begin
		if (targ>3) then (
			targ -=4
			sli := first child (slice child (lookupslice(sli:enemygrid), targ))
			dissolveSprite (sli, dissolve:vapourise, 22)
			specwait (20)
			set slice visible (sli, false)
		)
	end
end

#=======================================================================
#=======================================================================

script, animation, which, target, damage, begin
	variable (sli, sli2, speed, max, i)
	#setup to animate
	if (target < 4) then (
		sli := slice child(lookupslice(sli:herogrid), target)
	) else (
		sli := sliceChild(lookupslice(sli:enemygrid), target--4)
	)
	setupanimation (which, target)
	switch (which) do (	
		case (attack:normal) do (max := 4)
	)

	for (i, 0, max) do (
		animating(which, sli, i)
	)

	#end animation
	endanimation(which, sli, damage, target)
end

script, setupanimation, which, sli, begin
	switch (which) do (
		case (attack:normal) do (
		)
	)
	return (sli)
end

script, animating, which, sli, i,  begin
	variable(sli2)
	switch (which) do (
		case (attack:normal) do (
			switch (i) do (
				case (1) do (
					sli2 := loadSliceCollection(2)
					set parent (sli2, sli)
					specwait (10)
					free slice (sli2)
				)
				case (2) do (
					sli2 := loadSliceCollection(3)
					set parent (sli2, sli)
					specwait (10)
					free slice (sli2)
				)
				case (3) do (
					sli2 := loadSliceCollection(4)
					set parent (sli2, sli)
					specwait (10)
					free slice (sli2)
				)
			)
			
		)
	)
end

script, endanimation, which, sli, damage, target, begin
	variable (i)
	switch (which) do (
		case (attack:normal) do (
		)
	)
	for (i, 0, 4) do (
		if (i, mod, 2) then (
			set slice x (sli, 6--i)
		) else (
			set slice x (sli, -6+i)
		)
		specwait (6)
	)

	variable(sli2, ones, tens, hundreds)

	hundreds := modulus(damage/100,10)
	tens := modulus(damage/10,10)
	ones := modulus(damage/1,10)

	if (target < 4) then (
		sli2 := slice child(lookupslice(sli:herogrid), target)
	) else (
		sli2 := slice child(lookupslice(sli:enemygrid), target--4)
	)

	sli:= createGrid(72, 24, 0, 3)
	set parent (sli, sli2)
	center slice (sli)

	if (hundreds <> 0) then(
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, hundreds+1)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, tens+1)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, ones+1)
	) else if (tens <> 0)then (
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, tens+1)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, ones+1)
	) else(
		sli2 := create container
		set parent (sli2, sli)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, ones+1)
	)
	for (i, 0, 14) do (
		set slice y (sli, slicey(sli)--1)
		specwait (2)
	)
	sli2 := firstChild(sli)
	while (sli2) do (
		if (slice is sprite (sli2)) then (dissolve sprite (sli2, dissolve:puff, 20))
		sli2 := nextSibling(sli2)
	)
	for (i, 0, 9) do (
		set slice y (sli, slicey(sli)--1)
		specwait (2)
	)
	free slice (sli)
end

script, returndamage, mod1, mod2, extdam, type, healing, begin
	variable (var)

	extdam := extdam+100

	switch (type) do (
		case (damage:normal) do (var := mod1 -- mod2/2)
		case (damage:pure) do (var := mod1)
	)
	#var := var + multdiv (var, extdam, 100)

	if (var < 0) then (var := 0)

	var := var * healing

	return (var)
end

