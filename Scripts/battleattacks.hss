define constant, begin
	


	#values for below items
	1, damage:normal
	2, damage:pure
	
	30,	ticks:default

	0,	targClass:foeNotDead
	1,	targclass:allyNotDead
	2,	targclass:self
	3,	targclass:allNotDead
	4,	targclass:deadAlly

	0,	targSetting:focus
	1,	targSetting:spread

	0,	preferTarg:random
	1,	preferTarg:strongest
	2,	preferTarg:weakest

	12, weakStrongStat:targetstat

	1,	status:poison
	2,	status:paralyze
	3,	status:confused
	4,	status:burnt
	5,	status:frozen
	6,	status:mute
	7,	status:stun
	8,	status:regen
	9,	status:invincible
	10, status:shell
	11, status:reflect

	#skill array names
	25,	skill:names
	1,	skill:picture
	2,	skill:frameTicks
	3,	skill:sound
	4,	skill:targClass
	5,	skill:targSetting
	6,	skill:preferTarg
	7,	skill:weakStrongStat
	8,	skill:hits
	9,	skill:damageMath
	10,	skill:baseAtkStat
	11,	skill:baseDefStat
	12,	skill:targStat
	13,	skill:extraDamage
	14,	skill:PPcost
	15,	skill:HPcost
	16,	skill:MoneyCost
	17, skill:autoChooseTarg
	18, skill:stealitem
	19,	skill:stealPercent
	20,	skill:status
	21,	skill:statusPercent
	22,	skill:elementType
	23, skill:curebit
	24, skill:rowcheck
end

script, returnSkill, which,  begin
	variable (sli, i, var)

	#if (lookupSlice(array:readskill)<>0) then (
	#	free slice (lookupSlice(array:readskill))
	#)

	switch (which) do (
		case (0) do (template)
		else (template)
	)

	subscript, template, begin
		sli := initArray(skill:names, array:readskill,-2)
		setParent (sli, lookupSlice(sli:battleCol))
		#damage
			var := damage:normal
			setElement (sli, skill:picture, var)
		#frameTicks
			var := ticks:default
			setElement (sli, skill:frameTicks, var)
		#sound
			var := 0
			setElement (sli, skill:sound, var) 
		#targClass
			var := targClass:foeNotDead
			setElement (sli, skill:targClass, var)
		#targSetting
			var := targSetting:focus
			setElement (sli, skill:targSetting, var)
		#preferTarg
			var := preferTarg:random
			setElement (sli, skill:preferTarg, var)
		#weakStrongStat
			var := weakStrongStat:targetstat
			setElement (sli, skill:weakStrongStat, var) 
		#hits
			var := 1
			setElement (sli,skill:hits, var)
		#damageMath
			var := damage:normal
			setElement (sli,skill:damageMath, var)
		#baseAtkStat
			var := stat:atk
			setElement (sli,skill:baseAtkStat, var)
		#baseDefStat
			var := stat:def
			setElement (sli,skill:baseDefStat, var)
		#targStat
			var := stat:HP
			setElement (sli,skill:targStat, var)
		#extraDamage
			var := 0
			setElement (sli,skill:extraDamage, var)
		#PPcost
			var := false
			setElement (sli,skill:PPcost, var)
		#HPcost
			var := false
			setElement (sli,skill:HPcost, var)
		#MoneyCost
			var := false
			setElement (sli,skill:MoneyCost, var)
		#autoChooseTarg
			var := false
			setElement (sli,skill:autoChooseTarg, var)
		#stealitem
			var := false
			setElement (sli,skill:stealitem, var)
		#stealpercent
			var := false
			setElement (sli,skill:stealPercent, var)
		#status
			var := false
			setElement (sli,skill:status, var)
		#statusPercent
			var := false
			setElement (sli,skill:statusPercent, var)
		#elementType
			var := element:Norm
			setElement (sli,skill:elementType, var)
		#curebit
			var := 1
			setElement (sli,skill:curebit, var)
		#rowcheck
			var := true
			setElement (sli,skill:rowcheck, var)
	end
end


#=======================================================================
#=======================================================================

script, turns, begin
	variable (
		which, who, target, mod1, mod2, targstat, extdam
		sli, type, healing, damage, i, var
	)
	sli := lookupslice(array:turn)
	sortChildren (sli)

	while (firstChild (lookupslice(array:turn))) do (
		sli := firstChild (lookupslice(array:turn))
		which		:= getElement(sli, 0)
		who			:= getElement(sli, 1)
		target		:= getElement(sli, 2)

		returnSkill(which)
		sli := lookupslice (array:readskill)

		mod1 := readStat (who, getElement (sli,skill:baseAtkStat))
		mod2 := readStat (who, getElement (sli,skill:baseDefStat))

		damage	:= returndamage (
			mod1
			mod2
			getElement (sli,skill:extraDamage)
			getElement (sli,skill:damageMath)
			getElement (sli,skill:curebit)
		)

		if (getElement (sli,skill:rowcheck) == true && readStat(target, stat:row)==1) then (
			damage := damage -- damage/3
		)
		writeStat (target, getElement (sli,skill:targStat), readStat(target, getElement (sli,skill:targStat)) -- damage)
		if (readStat(target, getElement (sli,skill:targStat))<0) then(writeStat (target, getElement (sli,skill:targStat), 0))

		animation(which, target, damage)

		for (i, 0, herocount--1) do (
			setmeter (i, stat:hp)
			setmeter (i, stat:pp)
		)

		if (readstat(target, stat:HP)==0) then (KOTarget(target))
		battlecheck
		free slice (lookupSlice(array:readskill))
		freeSlice (firstChild (lookupslice(array:turn)))
	)
	initTurnArray()
	specwait (10)

	subscript, koTarget, targ, begin
		if (targ>3) then (
			targ -=4
			sli := first child (slice child (lookupslice(sli:enemygrid), targ))
			dissolveSprite (sli, dissolve:flicker, 22)
			specwait (20)
			set slice visible (sli, false)
		)
	end

	#subscript, readSkill, begin
	#	sli := getArray(array:readskill)

	#	getElement (sli, skill:picture)
	#	getElement (sli, skill:frameTicks)
	#	getElement (sli, skill:sound)
	#	getElement (sli, skill:targClass)
	#	getElement (sli, skill:targSetting)
	#	getElement (sli, skill:preferTarg)
	#	getElement (sli, skill:weakStrongStat) 
	#	getElement (sli,skill:hits)
	#	getElement (sli,skill:damageMath)
	#	getElement (sli,skill:baseAtkStat)
	#	getElement (sli,skill:baseDefStat)
	#	getElement (sli,skill:targStat)
	#	getElement (sli,skill:extraDamage)
	#	getElement (sli,skill:PPcost)
	#	getElement (sli,skill:HPcost)
	#	getElement (sli,skill:MoneyCost)
	#	getElement (sli,skill:autoChooseTarg)
	#	getElement (sli,skill:stealitem)
	#	getElement (sli,skill:stealPercent)
	#	getElement (sli,skill:status)
	#	getElement (sli,skill:statusPercent)
	#	getElement (sli,skill:elementType)
	#	getElement (sli,skill:curebit)
	#	getElement (sli,skill:rowcheck)
	#end
end

#=======================================================================
#=======================================================================

script, animation, which, target, damage, begin
	variable (sli, sli2, speed, max, i)
	#setup to animate
	if (target < 4) then (
		sli := slice child(lookupslice(sli:herogrid), target)
	) else (
		sli := sliceChild(lookupslice(sli:enemygrid), target--4)
	)
	setupanimation (which, target)
	switch (which) do (	
		case (attack:normal) do (max := 4)
	)

	for (i, 0, max) do (
		animating(which, sli, i)
	)

	#end animation
	endanimation(which, sli, damage, target)
end

script, setupanimation, which, sli, begin
	switch (which) do (
		case (attack:normal) do (
		)
	)
	return (sli)
end

script, animating, which, sli, i,  begin
	variable(sli2)
	switch (which) do (
		case (attack:normal) do (
			switch (i) do (
				case (1) do (
					sli2 := loadSliceCollection(2)
					set parent (sli2, sli)
					specwait (10)
					free slice (sli2)
				)
				case (2) do (
					sli2 := loadSliceCollection(3)
					set parent (sli2, sli)
					specwait (10)
					free slice (sli2)
				)
				case (3) do (
					sli2 := loadSliceCollection(4)
					set parent (sli2, sli)
					specwait (10)
					free slice (sli2)
				)
			)
			
		)
	)
end

script, endanimation, which, sli, damage, target, begin
	variable (i)
	switch (which) do (
		case (attack:normal) do (
		)
	)
	for (i, 0, 4) do (
		if (i, mod, 2) then (
			set slice x (sli, 6--i)
		) else (
			set slice x (sli, -6+i)
		)
		specwait (6)
	)

	variable(sli2, ones, tens, hundreds)

	hundreds := modulus(damage/100,10)
	tens := modulus(damage/10,10)
	ones := modulus(damage/1,10)

	if (target < 4) then (
		sli2 := slice child(lookupslice(sli:herogrid), target)
	) else (
		sli2 := slice child(lookupslice(sli:enemygrid), target--4)
	)

	sli:= createGrid(72, 24, 0, 3)
	set parent (sli, sli2)
	center slice (sli)

	if (hundreds <> 0) then(
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, hundreds+1)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, tens+1)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, ones+1)
	) else if (tens <> 0)then (
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, tens+1)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, ones+1)
	) else(
		sli2 := create container
		set parent (sli2, sli)
		sli2 := load border sprite(1)
		set parent (sli2, sli)
		set sprite frame (sli2, ones+1)
	)
	for (i, 0, 14) do (
		set slice y (sli, slicey(sli)--1)
		specwait (2)
	)
	sli2 := firstChild(sli)
	while (sli2) do (
		if (slice is sprite (sli2)) then (dissolve sprite (sli2, dissolve:puff, 20))
		sli2 := nextSibling(sli2)
	)
	for (i, 0, 9) do (
		set slice y (sli, slicey(sli)--1)
		specwait (2)
	)
	free slice (sli)
end

script, returndamage, mod1, mod2, extdam, type, healing, begin
	variable (var)

	extdam := extdam+100

	switch (type) do (
		case (damage:normal) do (var := mod1 -- mod2/2)
		case (damage:pure) do (var := mod1)
	)
	#var := var + multdiv (var, extdam, 100)

	if (var < 0) then (var := 0)

	var := var * healing

	return (var)
end

